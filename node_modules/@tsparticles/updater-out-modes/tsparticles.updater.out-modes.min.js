/*! For license information please see tsparticles.updater.out-modes.min.js.LICENSE.txt */
!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e(require("@tsparticles/engine"));else if("function"==typeof define&&define.amd)define(["@tsparticles/engine"],e);else{var o="object"==typeof exports?e(require("@tsparticles/engine")):e(t.window);for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(this,(t=>(()=>{var e={303:e=>{e.exports=t}},o={};function i(t){var n=o[t];if(void 0!==n)return n.exports;var s=o[t]={exports:{}};return e[t](s,s.exports,i),s.exports}i.d=(t,e)=>{for(var o in e)i.o(e,o)&&!i.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};i.r(n),i.d(n,{loadOutModesUpdater:()=>l});var s=i(303);class r{constructor(t){this.container=t,this.modes=[s.OutMode.bounce,s.OutMode.split]}update(t,e,o,i){if(!this.modes.includes(i))return;const n=this.container;let r=!1;for(const[,i]of n.plugins)if(void 0!==i.particleBounce&&(r=i.particleBounce(t,o,e)),r)break;if(r)return;const a=t.getPosition(),c=t.offset,d=t.getRadius(),u=(0,s.calculateBounds)(a,d),p=n.canvas.size;!function(t){if(t.outMode!==s.OutMode.bounce&&t.outMode!==s.OutMode.split||t.direction!==s.OutModeDirection.left&&t.direction!==s.OutModeDirection.right)return;t.bounds.right<0&&t.direction===s.OutModeDirection.left?t.particle.position.x=t.size+t.offset.x:t.bounds.left>t.canvasSize.width&&t.direction===s.OutModeDirection.right&&(t.particle.position.x=t.canvasSize.width-t.size-t.offset.x);const e=t.particle.velocity.x;let o=!1;if(t.direction===s.OutModeDirection.right&&t.bounds.right>=t.canvasSize.width&&e>0||t.direction===s.OutModeDirection.left&&t.bounds.left<=0&&e<0){const e=(0,s.getRangeValue)(t.particle.options.bounce.horizontal.value);t.particle.velocity.x*=-e,o=!0}if(!o)return;const i=t.offset.x+t.size;t.bounds.right>=t.canvasSize.width&&t.direction===s.OutModeDirection.right?t.particle.position.x=t.canvasSize.width-i:t.bounds.left<=0&&t.direction===s.OutModeDirection.left&&(t.particle.position.x=i),t.outMode===s.OutMode.split&&t.particle.destroy()}({particle:t,outMode:i,direction:e,bounds:u,canvasSize:p,offset:c,size:d}),function(t){if(t.outMode!==s.OutMode.bounce&&t.outMode!==s.OutMode.split||t.direction!==s.OutModeDirection.bottom&&t.direction!==s.OutModeDirection.top)return;t.bounds.bottom<0&&t.direction===s.OutModeDirection.top?t.particle.position.y=t.size+t.offset.y:t.bounds.top>t.canvasSize.height&&t.direction===s.OutModeDirection.bottom&&(t.particle.position.y=t.canvasSize.height-t.size-t.offset.y);const e=t.particle.velocity.y;let o=!1;if(t.direction===s.OutModeDirection.bottom&&t.bounds.bottom>=t.canvasSize.height&&e>0||t.direction===s.OutModeDirection.top&&t.bounds.top<=0&&e<0){const e=(0,s.getRangeValue)(t.particle.options.bounce.vertical.value);t.particle.velocity.y*=-e,o=!0}if(!o)return;const i=t.offset.y+t.size;t.bounds.bottom>=t.canvasSize.height&&t.direction===s.OutModeDirection.bottom?t.particle.position.y=t.canvasSize.height-i:t.bounds.top<=0&&t.direction===s.OutModeDirection.top&&(t.particle.position.y=i),t.outMode===s.OutMode.split&&t.particle.destroy()}({particle:t,outMode:i,direction:e,bounds:u,canvasSize:p,offset:c,size:d})}}class a{constructor(t){this.container=t,this.modes=[s.OutMode.destroy]}update(t,e,o,i){if(!this.modes.includes(i))return;const n=this.container;switch(t.outType){case s.ParticleOutType.normal:case s.ParticleOutType.outside:if((0,s.isPointInside)(t.position,n.canvas.size,s.Vector.origin,t.getRadius(),e))return;break;case s.ParticleOutType.inside:{const{dx:e,dy:o}=(0,s.getDistances)(t.position,t.moveCenter),{x:i,y:n}=t.velocity;if(i<0&&e>t.moveCenter.radius||n<0&&o>t.moveCenter.radius||i>=0&&e<-t.moveCenter.radius||n>=0&&o<-t.moveCenter.radius)return;break}}n.particles.remove(t,void 0,!0)}}class c{constructor(t){this.container=t,this.modes=[s.OutMode.none]}update(t,e,o,i){if(!this.modes.includes(i))return;if((t.options.move.distance.horizontal&&(e===s.OutModeDirection.left||e===s.OutModeDirection.right))??(t.options.move.distance.vertical&&(e===s.OutModeDirection.top||e===s.OutModeDirection.bottom)))return;const n=t.options.move.gravity,r=this.container,a=r.canvas.size,c=t.getRadius();if(n.enable){const o=t.position;(!n.inverse&&o.y>a.height+c&&e===s.OutModeDirection.bottom||n.inverse&&o.y<-c&&e===s.OutModeDirection.top)&&r.particles.remove(t)}else{if(t.velocity.y>0&&t.position.y<=a.height+c||t.velocity.y<0&&t.position.y>=-c||t.velocity.x>0&&t.position.x<=a.width+c||t.velocity.x<0&&t.position.x>=-c)return;(0,s.isPointInside)(t.position,r.canvas.size,s.Vector.origin,c,e)||r.particles.remove(t)}}}class d{constructor(t){this.container=t,this.modes=[s.OutMode.out]}update(t,e,o,i){if(!this.modes.includes(i))return;const n=this.container;switch(t.outType){case s.ParticleOutType.inside:{const{x:e,y:o}=t.velocity,i=s.Vector.origin;i.length=t.moveCenter.radius,i.angle=t.velocity.angle+Math.PI,i.addTo(s.Vector.create(t.moveCenter));const{dx:r,dy:a}=(0,s.getDistances)(t.position,i);if(e<=0&&r>=0||o<=0&&a>=0||e>=0&&r<=0||o>=0&&a<=0)return;t.position.x=Math.floor((0,s.randomInRange)({min:0,max:n.canvas.size.width})),t.position.y=Math.floor((0,s.randomInRange)({min:0,max:n.canvas.size.height}));const{dx:c,dy:d}=(0,s.getDistances)(t.position,t.moveCenter);t.direction=Math.atan2(-d,-c),t.velocity.angle=t.direction;break}default:if((0,s.isPointInside)(t.position,n.canvas.size,s.Vector.origin,t.getRadius(),e))return;switch(t.outType){case s.ParticleOutType.outside:{t.position.x=Math.floor((0,s.randomInRange)({min:-t.moveCenter.radius,max:t.moveCenter.radius}))+t.moveCenter.x,t.position.y=Math.floor((0,s.randomInRange)({min:-t.moveCenter.radius,max:t.moveCenter.radius}))+t.moveCenter.y;const{dx:e,dy:o}=(0,s.getDistances)(t.position,t.moveCenter);t.moveCenter.radius&&(t.direction=Math.atan2(o,e),t.velocity.angle=t.direction);break}case s.ParticleOutType.normal:{const o=t.options.move.warp,i=n.canvas.size,r={bottom:i.height+t.getRadius()+t.offset.y,left:-t.getRadius()-t.offset.x,right:i.width+t.getRadius()+t.offset.x,top:-t.getRadius()-t.offset.y},a=t.getRadius(),c=(0,s.calculateBounds)(t.position,a);e===s.OutModeDirection.right&&c.left>i.width+t.offset.x?(t.position.x=r.left,t.initialPosition.x=t.position.x,o||(t.position.y=(0,s.getRandom)()*i.height,t.initialPosition.y=t.position.y)):e===s.OutModeDirection.left&&c.right<-t.offset.x&&(t.position.x=r.right,t.initialPosition.x=t.position.x,o||(t.position.y=(0,s.getRandom)()*i.height,t.initialPosition.y=t.position.y)),e===s.OutModeDirection.bottom&&c.top>i.height+t.offset.y?(o||(t.position.x=(0,s.getRandom)()*i.width,t.initialPosition.x=t.position.x),t.position.y=r.top,t.initialPosition.y=t.position.y):e===s.OutModeDirection.top&&c.bottom<-t.offset.y&&(o||(t.position.x=(0,s.getRandom)()*i.width,t.initialPosition.x=t.position.x),t.position.y=r.bottom,t.initialPosition.y=t.position.y);break}}}}}const u=(t,e)=>t.default===e||t.bottom===e||t.left===e||t.right===e||t.top===e;class p{constructor(t){this._updateOutMode=(t,e,o,i)=>{for(const n of this.updaters)n.update(t,i,e,o)},this.container=t,this.updaters=[]}init(t){this.updaters=[];const e=t.options.move.outModes;u(e,s.OutMode.bounce)?this.updaters.push(new r(this.container)):u(e,s.OutMode.out)?this.updaters.push(new d(this.container)):u(e,s.OutMode.destroy)?this.updaters.push(new a(this.container)):u(e,s.OutMode.none)&&this.updaters.push(new c(this.container))}isEnabled(t){return!t.destroyed&&!t.spawning}update(t,e){const o=t.options.move.outModes;this._updateOutMode(t,e,o.bottom??o.default,s.OutModeDirection.bottom),this._updateOutMode(t,e,o.left??o.default,s.OutModeDirection.left),this._updateOutMode(t,e,o.right??o.default,s.OutModeDirection.right),this._updateOutMode(t,e,o.top??o.default,s.OutModeDirection.top)}}async function l(t,e=!0){await t.addParticleUpdater("outModes",(t=>Promise.resolve(new p(t))),e)}return n})()));